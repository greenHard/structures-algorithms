## 为什么要学习数据结构和算法呢?

1. 最近这段时间看了好多技术和文档，但每一次想深入去了解的时候都会涉及到数据结构。
2.  想在这个行业上越走越远, 作为一个非计算机专业的人, 计算机原理和组成和数据结构和算法都是我必须要补充的东西。
3.  想写出更优雅和效率更高的代码。

## 数据结构与算法

### 数据结构与算法的定义

- 广义上讲: **数据结构**: 是一组数据的**存储结构**。**算法**: 操作数据的**一组方法**。
- 狭义上讲: 某些著名的数据结构和算法。例如: 队列、栈、堆、二分查找等。

图书馆储藏书籍，为了方便查找，图书管理员一般会将书籍分门别类进行“存储”。按照一定规律编号，就是书籍这种“数据”的存储结构。

那我们如何来查找一本书呢？有很多种办法，你当然可以一本一本地找，也可以先根据书籍类别的编号，是人文，还是科学、计算机，来定位书架，然后再依次查找。这些查找方法都是算法。

### 数据结构与算法的关系

**数据结构和算法是相辅相成的, 数据结构是为算法服务的，算法要作用在特定的数据结构之上。**

> 例如: 数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。

### 常见的数据结构和算法

- **常用的10个数据结构**:  数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树。
- **常用的10个算法**: 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

### 学习数据结构与算法的小技巧

- 边学边练，[适度刷题](https://leetcode.com/)
- 多问、多思考、多互动
- 知识需要沉淀，不要想试图一下子掌握所有

### 复杂度分析

**复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本掌握了一半**

#### 为什么要有复杂度分析?

把代码跑一遍，通过统计、监控，就能得到算法的执行时间和占用空间大小。为什么还要做时间、空间复杂度分析?  

这种评估算法执行效率的方法是正确的。很多数据结构和算法的书籍还给起了一个名字，叫**事后统计法**。但是这种方法有非常大的**局限性**。

1. 测试结果非常依赖测试环境  

2. 测试结果受数据规模影响很大

> 我们需要一个不用**具体的**测试数据和测试，就可以**粗略**地估计**算法的执行效率**的方法。这就是**时间复杂度**和**空间复杂度分析**。

#### 大O复杂度表示法

```java
1 int cal(int n){
2   int sum = 0;
3   int i = 1;
4   for(; i<=n;++i){
5      sum = sum + i;
6   }
7   return sum;
8 }
```

假设每行代码的执行时间都一样，为unit_time。在这个假设的基础上，该段代码的总执行时间 T(n) 是多少呢?

第2、3行代码每行都需要1个unit_time的时间，第4、5行每行都执行了n遍，需要 2n *unit_time的时间，所以这段代码总的执行时间为 (2n + 2) * unit_time。可以看出来，**所有的代码执行时间 T(n)与每行代码的执行次数n成正比。** 

我们把这个规律总结成一个公式 :

$$
T(n) = O(f(n))
$$


> n:  表示数据规模的大小
> f(n):  表示执行代码的次数总和
> O:  表示T(n)与f(n)成正比

大O时间复杂度实际上并不具体表示代码的真正执行时间，而是表示代码执行时间随着数据规模增长的变化趋势，所以，也叫**渐进时间复杂度**，简称**时间复杂度**。

> 当n很大时，低阶、常量和系数并不能左右增长趋势，所以都可以忽略，我们只要记录最大的量级就可以了。

#### 时间复杂度分析技巧

- 只关注执行次数最多的一段代码

- 加法法则: 总时间复杂度等于量级最大的那段代码的时间复杂度

- 乘法法则: 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

#### 几种常见的时间复杂度实例分析?

![](C:\Users\zhangyuyang\Desktop\1553667962(1).jpg)

> 非多项式量级: 当n逐渐增大时，执行时间会急剧增加。

#### Q&A

有人说我们项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢? 而且，每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢? 你怎么看待这个问题?

​	答: (1) 渐进时间复杂度和渐进空间复杂度为我们提供了一个很好的理论分析的方向，它与平台无关，能够让我们对一个程序或算法有一个特定的认识。让我们知道在最坏的情况下，效率是如何的。

​	     (2) 渐进时间复杂度和渐进空间复杂度只是一个理论模型，只能粗略的给出分析，我们不能直接就断定`O(logn)`就一定比`O(n)`快，针对不同的情况进行一定的基准性能测试是有必要的。最终选择最优的算法。

​	   (3) 所以时间复杂度、空间复杂度分析和性能测试并不冲突, 这两个是相辅相成的，但是一个低价的时间复杂度有极大的可能会优于高阶的时间复杂度程序。所以在实际编程中，时刻关注理论时间、空间模型是有助于产出效率高的程序的。同时，因为渐进式时间、空间复杂度只是一个粗略的时间模型，并不会浪费太多时间，重点在于编程，要具有这种复杂度分析的思维。

#### 最好、最坏、平均、均摊复杂度

##### 最好、最坏时间复杂度

```JAVA
// n表示数组 array 的长度
int find(int[] array, int n, int x){
    int i = 0;
    int pos = -1;
    for(; i<n; i++){
        if(array[i] == x){
            pos = i;
            break;
        }
    }
}
```

**思路分析**:  如果数组中**第一个元素**正好是要查找的变量x，那就不需要继续遍历剩下n-1个数据，那时间复杂度就是 **O(1)**。但如果数组中不存在x, 那我们就需要将数组都遍历一编，时间复杂度就成了**O(n)**。所以，不同的情况下，这段代码的时间复杂度是不一样的。

为了表示不同情况下的不同时间复杂度，我们需要引入三个概念: **最好情况时间复杂度**、**最坏情况时间复杂度**和**平均时间复杂度**。

- 最好情况时间复杂度: 在最理想的情况下，执行这段代码的时间复杂度。

- 最坏情况时间复杂度: 在最糟糕的情况下，执行这段代码的时间复杂度。

  > 最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度。

##### 平均情况时间复杂度

要查找的变量 x 在数组中的位置，我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起 来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的 数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找 的数据出现在  0～n-1 中任意位置的概率就是 1/(2n)。

![](C:\Users\zhangyuyang\Desktop\11.jpg)

这个值就是概率论中的**加权平均值**，也叫作**期望值**，所以平均时间复杂度的全称应该叫**加权平均间复杂度**或者**期望时间复杂度**

##### 均摊时间复杂度

```java
int[] array = new int[n];
int count = 0;
void insert(int val) {
    if (count == array.length) {
		int sum = 0;
		for (int i = 0; i < array.length; ++i) { 
            sum = sum + array[i];
		}
		array[0] = sum; 
        count = 1;
	}
		array[count] = val;
		++count;
}
```

这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和 之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。

那这段代码的时间复杂度是多少呢？你可以先用我们刚讲到的三种时间复杂度的分析方法来分析 一下。

最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可 以了，所以最好情况时间复杂度为 O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做 一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为  O(n)。

我们 先来对比一下这个  insert()  的例子和前面那个  ﬁnd() 的例子，你就会发现这两者有很大差别？

首先，ﬁnd()  函数在极端情况下，复杂度才为  O(1)。但  insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()第一个区别于 ﬁnd() 的地 方。

我们再来看第二个不同的地方。对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复 杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插 入之后，紧跟着 n-1 个 O(1)  的插入操作，循环往复。

针对这种特殊的场景，我们引入了一种更加简单的分析方法：摊还分析法，通过摊还分析得到的 时间复杂度我们起了一个名字，叫**均摊时间复杂度**。

继续看在数组中插入数据的这个例子。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一 组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路。

##### 练习题

```java
// 全局变量，大小为10的数组array，长度 len，下标i
int array[] = new int[10];
int len = 10;
int i = 0；

// 往数组中添加一个元素
void add(int element) {
	if (i >= len) { // 数组空间不够了
		// 重新申请一个2倍大小的数组空间
		int new_array[] = new int[len*2];		
		// 把原来array数组中的数据依次copy到new_array
		for (int j = 0; j < len; ++j) { 
			new_array[j] = array[j];
		}
		// new_array复制给array，array现在大小就是2倍len了		
		array = new_array; 
		len = 2 * len;
	}
	// 将 element放到下标为i的位置，下标i加一
	array[i] = element;
	++i;
}
```

答: 最好时间复杂度O(1)、最坏时间复杂度O(n)、均摊时间复杂度O(1)

